Microsoft (R) Macro Assembler Version 14.23.28106.4	    12/10/19 00:59:07
	test3.as					     Page 1 - 1


				TITLE test3.asm
				; Program description: pllays tic tac toe with a few options for game modes
				; Author: Muhammad Hussain
				; Creation date: 12/7/19

				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 







				COMMENT @

				issues and bugs:

				I emailed about these problems ealier. 

				There's a problem where call Delay doesn't work. It's commented out at the moment, but if you
				search ctrl+f for "delay" you can see where it is. The program just works life it's not there. 

				Also, waitmsg prompts need quite a few presses to actually get through sometimes. 

				@









				ClearRegs proto
				DisplayMenu proto,
					menOff:dword
				DisplayGvG proto,
					gvgOff:dword
				ClearBoard proto,
					boardOff:dword
				FirstMoveRand proto,
					fmOff:dword
				PlayerMove proto, 
					offStr:dword,
					pieceVal:byte, 
					boardOff:dword
				CheckIfEmpty proto,
					boardOff:dword, 
					empOff:dword,
					rowIn:dword,
					colIn:dword
				PutPieceIn proto,
					boardOff:dword, 
					rowIn:dword,
					colIn:dword, 
					pieceVal:byte
				AnnounceFirstMove proto
				DrawTTTBoard proto, 
					boardOff:dword, 
					pieceVal:byte
				FlipActivePiece proto,
					apOff:dword
				ResetColor proto
				ComputerMove proto, 
					offStr:dword,
					pieceVal:byte,
					boardOff:dword
				writeSpace proto
				CheckGameOver proto,
					boardOff:dword,
					goOff:dword, 
					winVal:byte
				CheckForDraw proto,
					boardOff:dword,
					retOff:dword
				PrintWinner proto,
					winOff:dword
				PrintStats proto,
					lpvcgp:byte,
					lpvpgp:byte, 
					lcvcgp:byte, 
					lp1win:byte, 
					lp2win:byte, 
					lc1win:byte, 
					lc2win:byte, 
					ldraws:byte 

 00000000			.data

 00000000 00				menuOption byte 0
					;gvgOption byte 2d

 00000001 21 21 21			TTTArray byte 21h, 21h, 21h
 00000004 = 00000003			rowSize = ($ - TTTArray)
 00000004  21 21 21						byte 21h, 21h, 21h
 00000007  21 21 21						byte 21h, 21h, 21h

					;pwrArray byte 21h, 21h, 21h
					;rowSize2 = ($ - TTTArray)
				;				byte 21h, 21h, 21h
				;				byte 21h, 21h, 21h

 0000000A 00				firstMoveDec byte 0

 0000000B 6E 6F 62 6F 64		nobodys1 byte "nobody", 0
	   79 00

 00000012 70 6C 61 79 65		pstring1 byte "player 1", 0
	   72 20 31 00
 0000001B 70 6C 61 79 65		pstring2 byte "player 2", 0
	   72 20 32 00

 00000024 43 4F 4D 50 55		cstring1 byte "COMPUTER 1", 0
	   54 45 52 20 31
	   00
 0000002F 43 4F 4D 50 55		cstring2 byte "COMPUTER 2", 0
	   54 45 52 20 32
	   00

 0000003A 01				currentPiece byte 1d

 0000003B 00				goCondition byte 0d

 0000003C 00				drawCondition byte 0d


 0000003D 00				pvcgp byte 0
 0000003E 00				pvpgp byte 0
 0000003F 00				cvcgp byte 0
 00000040 00				p1win byte 0
 00000041 00				p2win byte 0
 00000042 00				c1win byte 0
 00000043 00				c2win byte 0
 00000044 00				draws byte 0

 00000000			.data?

 00000000			.code
 00000000			main proc

				; Menu
 00000000			MenuL: 
					
 00000000  C6 05 0000003A R		mov currentPiece, 1d
	   01
 00000007  C6 05 0000003B R		mov goCondition, 0d
	   00
 0000000E  C6 05 0000003C R		mov drawCondition, 0d
	   00

					;INVOKE ResetColor
 00000015  E8 00000000 E		call clrscr

					; clear registers 
					;INVOKE ClearRegs
 0000001A  E8 00000000 E		call randomize
					
					; clear the 2d array for TTT
					INVOKE ClearBoard, offset TTTArray
 0000001F  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000024  E8 00000C47	   *	    call   ClearBoard
					;INVOKE ClearBoard, offset pwrArray

					; decide who does first 
					INVOKE FirstMoveRand, offset firstMoveDec
 00000029  68 0000000A R   *	    push   dword  ptr OFFSET FLAT: firstMoveDec
 0000002E  E8 00000C04	   *	    call   FirstMoveRand

					; set current piece to X
 00000033  C6 05 0000003A R		mov currentPiece, 1d
	   01

					INVOKE DisplayMenu, offset menuOption
 0000003A  68 00000000 R   *	    push   dword  ptr OFFSET FLAT: menuOption
 0000003F  E8 00000CA9	   *	    call   DisplayMenu
					;cmp menuOption, 3
					;ja statsl
					;INVOKE DisplayGvG, offset gvgOption






 00000044			PvCl:
 00000044  80 3D 00000000 R		cmp menuOption, 1
	   01
 0000004B  0F 85 000001B5		jne PvPl

 00000051  E8 00000000 E		call clrscr

					; draw board 
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 00000056  A0 0000003A R   *	    mov    al, currentPiece
 0000005B  50		   *	    push   eax
 0000005C  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000061  E8 000009F2	   *	    call   DrawTTTBoard

					; tell players move order was selected at random
					INVOKE AnnounceFirstMove 
 00000066  E8 00000BE6	   *	    call   AnnounceFirstMove

 0000006B  80 3D 0000000A R		cmp firstMoveDec, 0
	   00
 00000072  0F 85 0000008E		jne firstMove2

 00000078			firstMove1:
					;call clearregs
					; player move 
					INVOKE playerMove, offset pstring1, currentPiece, offset TTTArray
 00000078  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000007D  A0 0000003A R   *	    mov    al, currentPiece
 00000082  50		   *	    push   eax
 00000083  68 00000012 R   *	    push   dword  ptr OFFSET FLAT: pstring1
 00000088  E8 00000ACE	   *	    call   PlayerMove
					;call clearregs

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 0000008D  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 00000092  E8 00000AA8	   *	    call   FlipActivePiece

					; draw board
 00000097  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 0000009C  A0 0000003A R   *	    mov    al, currentPiece
 000000A1  50		   *	    push   eax
 000000A2  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000000A7  E8 000009AC	   *	    call   DrawTTTBoard

					; run gvg ;;;;;;;;;;;;;;;;;;;;;


					; check game over
 000000AC  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 000000AE  50		   *	    push   eax
 000000AF  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 000000B4  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000000B9  E8 000006B7	   *	    call   CheckGameOver
 000000BE  80 3D 0000003B R		cmp goCondition, 0
	   00
 000000C5  0F 85 000000C7		jne winDet0
 000000CB  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 000000CD  50		   *	    push   eax
 000000CE  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 000000D3  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000000D8  E8 00000698	   *	    call   CheckGameOver
 000000DD  80 3D 0000003B R		cmp goCondition, 0
	   00
 000000E4  0F 85 000000A8		jne winDet0
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 000000EA  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 000000EF  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000000F4  E8 00000606	   *	    call   CheckForDraw
 000000F9  80 3D 0000003C R		cmp drawCondition, 0
	   00
 00000100  0F 85 000000E1		jne DrawDet0

 00000106			firstMove2:
					;call clearregs
					; computer move 
					INVOKE ComputerMove, offset cstring1, currentPiece, offset TTTArray
 00000106  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000010B  A0 0000003A R   *	    mov    al, currentPiece
 00000110  50		   *	    push   eax
 00000111  68 00000024 R   *	    push   dword  ptr OFFSET FLAT: cstring1
 00000116  E8 00000864	   *	    call   ComputerMove

					;call clearregs

 0000011B  E8 00000000 E		call waitmsg

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 00000120  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 00000125  E8 00000A15	   *	    call   FlipActivePiece

					; draw board 
 0000012A  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 0000012F  A0 0000003A R   *	    mov    al, currentPiece
 00000134  50		   *	    push   eax
 00000135  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000013A  E8 00000919	   *	    call   DrawTTTBoard

					; run gvg ;;;;;;;;;;;;;;;;;;;;;


					; check game over 
 0000013F  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 00000141  50		   *	    push   eax
 00000142  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000147  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000014C  E8 00000624	   *	    call   CheckGameOver
 00000151  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000158  75 38			jne winDet0
 0000015A  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 0000015C  50		   *	    push   eax
 0000015D  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000162  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000167  E8 00000609	   *	    call   CheckGameOver
 0000016C  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000173  75 1D			jne winDet0
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 00000175  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 0000017A  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000017F  E8 0000057B	   *	    call   CheckForDraw
 00000184  80 3D 0000003C R		cmp drawCondition, 0
	   00
 0000018B  75 5A			jne DrawDet0


 0000018D  E9 FFFFFEE6			jmp firstMove1
 00000192			winDet0:
					
 00000192  B8 00000000			mov eax, 0
 00000197  02 05 0000000A R		add al, firstMoveDec
 0000019D  02 05 0000003B R		add al, goCondition

 000001A3  3C 02			cmp al, 2
 000001A5  74 20			je WinTree0

 000001A7			WinTree1: ; player 1 win

					INVOKE PrintWinner, offset pstring1
 000001A7  68 00000012 R   *	    push   dword  ptr OFFSET FLAT: pstring1
 000001AC  E8 0000045D	   *	    call   PrintWinner
 000001B1  FE 05 0000003D R		inc pvcgp
 000001B7  FE 05 00000040 R		inc p1win
 000001BD  E8 00000000 E		call waitmsg

 000001C2  E9 FFFFFE39			jmp MenuL
 000001C7			WinTree0: ; comp 1 win

					INVOKE PrintWinner, offset cstring1
 000001C7  68 00000024 R   *	    push   dword  ptr OFFSET FLAT: cstring1
 000001CC  E8 0000043D	   *	    call   PrintWinner
 000001D1  FE 05 0000003D R		inc pvcgp
 000001D7  FE 05 00000042 R		inc c1win
 000001DD  E8 00000000 E		call waitmsg

 000001E2  E9 FFFFFE19			jmp MenuL
 000001E7			DrawDet0: ; draw
					INVOKE PrintWinner, offset nobodys1
 000001E7  68 0000000B R   *	    push   dword  ptr OFFSET FLAT: nobodys1
 000001EC  E8 0000041D	   *	    call   PrintWinner
 000001F1  FE 05 00000044 R		inc draws
 000001F7  E8 00000000 E		call waitmsg

 000001FC  E9 FFFFFDFF			jmp MenuL
 00000201			PvCle:
 00000201  E9 FFFFFDFA			jmp MenuL












 00000206			PvPl:
 00000206  80 3D 00000000 R		cmp menuOption, 2
	   02
 0000020D  0F 85 000001B0		jne CvCl


 00000213  E8 00000000 E		call clrscr

					; draw board 
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 00000218  A0 0000003A R   *	    mov    al, currentPiece
 0000021D  50		   *	    push   eax
 0000021E  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000223  E8 00000830	   *	    call   DrawTTTBoard

					; tell players move order was selected at random
					INVOKE AnnounceFirstMove 
 00000228  E8 00000A24	   *	    call   AnnounceFirstMove

 0000022D  80 3D 0000000A R		cmp firstMoveDec, 0
	   00
 00000234  0F 85 0000008E		jne firstMove4

 0000023A			firstMove3:
					; player 1 move
					;call clearregs
					; player move 
					INVOKE playerMove, offset pstring1, currentPiece, offset TTTArray
 0000023A  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000023F  A0 0000003A R   *	    mov    al, currentPiece
 00000244  50		   *	    push   eax
 00000245  68 00000012 R   *	    push   dword  ptr OFFSET FLAT: pstring1
 0000024A  E8 0000090C	   *	    call   PlayerMove
					;call clearregs

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 0000024F  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 00000254  E8 000008E6	   *	    call   FlipActivePiece

					; draw board
 00000259  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 0000025E  A0 0000003A R   *	    mov    al, currentPiece
 00000263  50		   *	    push   eax
 00000264  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000269  E8 000007EA	   *	    call   DrawTTTBoard

					; check game over
 0000026E  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 00000270  50		   *	    push   eax
 00000271  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000276  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000027B  E8 000004F5	   *	    call   CheckGameOver
 00000280  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000287  0F 85 000000C2		jne winDet1
 0000028D  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 0000028F  50		   *	    push   eax
 00000290  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000295  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000029A  E8 000004D6	   *	    call   CheckGameOver
 0000029F  80 3D 0000003B R		cmp goCondition, 0
	   00
 000002A6  0F 85 000000A3		jne winDet1
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 000002AC  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 000002B1  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000002B6  E8 00000444	   *	    call   CheckForDraw
 000002BB  80 3D 0000003C R		cmp drawCondition, 0
	   00
 000002C2  0F 85 000000DC		jne DrawDet1

 000002C8			firstMove4:
					; player 2 move
					;call clearregs
					; player move 
					INVOKE playerMove, offset pstring2, currentPiece, offset TTTArray
 000002C8  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000002CD  A0 0000003A R   *	    mov    al, currentPiece
 000002D2  50		   *	    push   eax
 000002D3  68 0000001B R   *	    push   dword  ptr OFFSET FLAT: pstring2
 000002D8  E8 0000087E	   *	    call   PlayerMove
					;call clearregs

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 000002DD  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 000002E2  E8 00000858	   *	    call   FlipActivePiece

					; draw board
 000002E7  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 000002EC  A0 0000003A R   *	    mov    al, currentPiece
 000002F1  50		   *	    push   eax
 000002F2  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000002F7  E8 0000075C	   *	    call   DrawTTTBoard

					; check game over
 000002FC  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 000002FE  50		   *	    push   eax
 000002FF  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000304  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000309  E8 00000467	   *	    call   CheckGameOver
 0000030E  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000315  75 38			jne winDet1
 00000317  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 00000319  50		   *	    push   eax
 0000031A  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 0000031F  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000324  E8 0000044C	   *	    call   CheckGameOver
 00000329  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000330  75 1D			jne winDet1
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 00000332  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 00000337  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000033C  E8 000003BE	   *	    call   CheckForDraw
 00000341  80 3D 0000003C R		cmp drawCondition, 0
	   00
 00000348  75 5A			jne DrawDet1

 0000034A  E9 FFFFFEEB			jmp firstMove3

 0000034F			winDet1:
					
 0000034F  B8 00000000			mov eax, 0
 00000354  02 05 0000000A R		add al, firstMoveDec
 0000035A  02 05 0000003B R		add al, goCondition

 00000360  3C 02			cmp al, 2
 00000362  74 20			je WinTree3
 00000364			WinTree4: ; player 1 win

					INVOKE PrintWinner, offset pstring1
 00000364  68 00000012 R   *	    push   dword  ptr OFFSET FLAT: pstring1
 00000369  E8 000002A0	   *	    call   PrintWinner
 0000036E  FE 05 0000003E R		inc pvpgp
 00000374  FE 05 00000040 R		inc p1win
 0000037A  E8 00000000 E		call waitmsg

 0000037F  E9 FFFFFC7C			jmp MenuL
 00000384			WinTree3: ; player 2 win

					INVOKE PrintWinner, offset pstring2
 00000384  68 0000001B R   *	    push   dword  ptr OFFSET FLAT: pstring2
 00000389  E8 00000280	   *	    call   PrintWinner
 0000038E  FE 05 0000003E R		inc pvpgp
 00000394  FE 05 00000041 R		inc p2win
 0000039A  E8 00000000 E		call waitmsg

 0000039F  E9 FFFFFC5C			jmp MenuL
 000003A4			DrawDet1: ; draw
					INVOKE PrintWinner, offset nobodys1
 000003A4  68 0000000B R   *	    push   dword  ptr OFFSET FLAT: nobodys1
 000003A9  E8 00000260	   *	    call   PrintWinner
 000003AE  FE 05 00000044 R		inc draws
 000003B4  E8 00000000 E		call waitmsg

 000003B9  E9 FFFFFC42			jmp MenuL

 000003BE			PvPle:
 000003BE  E9 FFFFFC3D			jmp MenuL









 000003C3			CvCl:
 000003C3  80 3D 00000000 R		cmp menuOption, 3
	   03
 000003CA  0F 85 000001BA		jne statsl



 000003D0  E8 00000000 E		call clrscr

					; draw board 
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 000003D5  A0 0000003A R   *	    mov    al, currentPiece
 000003DA  50		   *	    push   eax
 000003DB  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000003E0  E8 00000673	   *	    call   DrawTTTBoard

					; tell players move order was selected at random
					INVOKE AnnounceFirstMove 
 000003E5  E8 00000867	   *	    call   AnnounceFirstMove

 000003EA  80 3D 0000000A R		cmp firstMoveDec, 0
	   00
 000003F1  0F 85 00000093		jne firstMove6

 000003F7			firstMove5:
					; computer 1 move
					;call clearregs
					; computer move 
					INVOKE ComputerMove, offset cstring1, currentPiece, offset TTTArray
 000003F7  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000003FC  A0 0000003A R   *	    mov    al, currentPiece
 00000401  50		   *	    push   eax
 00000402  68 00000024 R   *	    push   dword  ptr OFFSET FLAT: cstring1
 00000407  E8 00000573	   *	    call   ComputerMove

					;call clearregs

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 0000040C  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 00000411  E8 00000729	   *	    call   FlipActivePiece


 00000416  E8 00000000 E		call waitmsg
					;mov eax, 0
					;mov eax, 1000d
					;call Delay


					; draw board 
 0000041B  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 00000420  A0 0000003A R   *	    mov    al, currentPiece
 00000425  50		   *	    push   eax
 00000426  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000042B  E8 00000628	   *	    call   DrawTTTBoard


					; check game over
 00000430  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 00000432  50		   *	    push   eax
 00000433  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000438  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000043D  E8 00000333	   *	    call   CheckGameOver
 00000442  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000449  0F 85 000000C7		jne winDet3
 0000044F  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 00000451  50		   *	    push   eax
 00000452  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 00000457  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000045C  E8 00000314	   *	    call   CheckGameOver
 00000461  80 3D 0000003B R		cmp goCondition, 0
	   00
 00000468  0F 85 000000A8		jne winDet3
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 0000046E  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 00000473  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000478  E8 00000282	   *	    call   CheckForDraw
 0000047D  80 3D 0000003C R		cmp drawCondition, 0
	   00
 00000484  0F 85 000000E1		jne DrawDet3



 0000048A			firstMove6:
					; computer 2 move
					;call clearregs
					; computer move 
					INVOKE ComputerMove, offset cstring2, currentPiece, offset TTTArray
 0000048A  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 0000048F  A0 0000003A R   *	    mov    al, currentPiece
 00000494  50		   *	    push   eax
 00000495  68 0000002F R   *	    push   dword  ptr OFFSET FLAT: cstring2
 0000049A  E8 000004E0	   *	    call   ComputerMove

					;call clearregs

					; flip active piece 
					INVOKE FlipActivePiece, offset currentPiece
 0000049F  68 0000003A R   *	    push   dword  ptr OFFSET FLAT: currentPiece
 000004A4  E8 00000696	   *	    call   FlipActivePiece

 000004A9  E8 00000000 E		call waitmsg
					;mov eax, 0
					;mov eax, 1000d
					;call Delay


					; draw board 
 000004AE  E8 00000000 E		call clrscr
					INVOKE DrawTTTBoard, offset TTTArray, currentPiece
 000004B3  A0 0000003A R   *	    mov    al, currentPiece
 000004B8  50		   *	    push   eax
 000004B9  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000004BE  E8 00000595	   *	    call   DrawTTTBoard

					
					; check game over
 000004C3  B0 01			mov al, 1d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 000004C5  50		   *	    push   eax
 000004C6  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 000004CB  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000004D0  E8 000002A0	   *	    call   CheckGameOver
 000004D5  80 3D 0000003B R		cmp goCondition, 0
	   00
 000004DC  75 38			jne winDet3
 000004DE  B0 02			mov al, 2d
					INVOKE CheckGameOver, offset TTTArray, offset goCondition, al
 000004E0  50		   *	    push   eax
 000004E1  68 0000003B R   *	    push   dword  ptr OFFSET FLAT: goCondition
 000004E6  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 000004EB  E8 00000285	   *	    call   CheckGameOver
 000004F0  80 3D 0000003B R		cmp goCondition, 0
	   00
 000004F7  75 1D			jne winDet3
					; also check draw 
					INVOKE CheckForDraw, offset TTTArray, offset drawCondition
 000004F9  68 0000003C R   *	    push   dword  ptr OFFSET FLAT: drawCondition
 000004FE  68 00000001 R   *	    push   dword  ptr OFFSET FLAT: TTTArray
 00000503  E8 000001F7	   *	    call   CheckForDraw
 00000508  80 3D 0000003C R		cmp drawCondition, 0
	   00
 0000050F  75 5A			jne DrawDet3

 00000511  E9 FFFFFEE1			jmp firstMove5

 00000516			winDet3:
					
 00000516  B8 00000000			mov eax, 0
 0000051B  02 05 0000000A R		add al, firstMoveDec
 00000521  02 05 0000003B R		add al, goCondition

 00000527  3C 02			cmp al, 2
 00000529  74 20			je WinTree7
 0000052B			WinTree8: ; comp 1 win

					INVOKE PrintWinner, offset cstring1
 0000052B  68 00000024 R   *	    push   dword  ptr OFFSET FLAT: cstring1
 00000530  E8 000000D9	   *	    call   PrintWinner
 00000535  FE 05 0000003F R		inc cvcgp
 0000053B  FE 05 00000042 R		inc c1win
 00000541  E8 00000000 E		call waitmsg

 00000546  E9 FFFFFAB5			jmp MenuL
 0000054B			WinTree7: ; comp 2 win

					INVOKE PrintWinner, offset cstring2
 0000054B  68 0000002F R   *	    push   dword  ptr OFFSET FLAT: cstring2
 00000550  E8 000000B9	   *	    call   PrintWinner
 00000555  FE 05 0000003F R		inc cvcgp
 0000055B  FE 05 00000043 R		inc c2win
 00000561  E8 00000000 E		call waitmsg

 00000566  E9 FFFFFA95			jmp MenuL
 0000056B			DrawDet3: ; draw
					INVOKE PrintWinner, offset nobodys1
 0000056B  68 0000000B R   *	    push   dword  ptr OFFSET FLAT: nobodys1
 00000570  E8 00000099	   *	    call   PrintWinner
 00000575  FE 05 00000044 R		inc draws
 0000057B  E8 00000000 E		call waitmsg

 00000580  E9 FFFFFA7B			jmp MenuL

 00000585			CvCle:
 00000585  E9 FFFFFA76			jmp MenuL








 0000058A			statsl:
 0000058A  80 3D 00000000 R		cmp menuOption, 4
	   04
 00000591  75 3F			jne exitl
					
					; print all the stats
					INVOKE printStats, pvcgp, pvpgp, cvcgp, p1win, p2win, c1win, c2win, draws 
 00000593  A0 00000044 R   *	    mov    al, draws
 00000598  50		   *	    push   eax
 00000599  A0 00000043 R   *	    mov    al, c2win
 0000059E  50		   *	    push   eax
 0000059F  A0 00000042 R   *	    mov    al, c1win
 000005A4  50		   *	    push   eax
 000005A5  A0 00000041 R   *	    mov    al, p2win
 000005AA  50		   *	    push   eax
 000005AB  A0 00000040 R   *	    mov    al, p1win
 000005B0  50		   *	    push   eax
 000005B1  A0 0000003F R   *	    mov    al, cvcgp
 000005B6  50		   *	    push   eax
 000005B7  A0 0000003E R   *	    mov    al, pvpgp
 000005BC  50		   *	    push   eax
 000005BD  A0 0000003D R   *	    mov    al, pvcgp
 000005C2  50		   *	    push   eax
 000005C3  E8 00000064	   *	    call   PrintStats
 000005C8  E8 00000000 E		call waitmsg

 000005CD  E9 FFFFFA2E			jmp MenuL
 000005D2			exitl:

					; print stats and exit
					INVOKE printStats, pvcgp, pvpgp, cvcgp, p1win, p2win, c1win, c2win, draws 
 000005D2  A0 00000044 R   *	    mov    al, draws
 000005D7  50		   *	    push   eax
 000005D8  A0 00000043 R   *	    mov    al, c2win
 000005DD  50		   *	    push   eax
 000005DE  A0 00000042 R   *	    mov    al, c1win
 000005E3  50		   *	    push   eax
 000005E4  A0 00000041 R   *	    mov    al, p2win
 000005E9  50		   *	    push   eax
 000005EA  A0 00000040 R   *	    mov    al, p1win
 000005EF  50		   *	    push   eax
 000005F0  A0 0000003F R   *	    mov    al, cvcgp
 000005F5  50		   *	    push   eax
 000005F6  A0 0000003E R   *	    mov    al, pvpgp
 000005FB  50		   *	    push   eax
 000005FC  A0 0000003D R   *	    mov    al, pvcgp
 00000601  50		   *	    push   eax
 00000602  E8 00000025	   *	    call   PrintStats

				exit
 00000607  6A 00	   *	    push   +000000000h
 00000609  E8 00000000 E   *	    call   ExitProcess
 0000060E			main endp






				COMMENT @
				Print who won! Hooray!
				recieves:
				a string for the winner
				returns:
				nothing
				requires:
				edx registers
				@
 0000060E			PrintWinner proc,
					winOff:dword
 0000060E  55		   *	    push   ebp
 0000060F  8B EC	   *	    mov    ebp, esp
 00000045			.data
 00000045 20 68 61 73 20		PWprom1 byte " has won!",0 
	   77 6F 6E 21 00

 00000611			.code
 00000611  8B 55 08			mov edx, winOff ; print the input string
 00000614  E8 00000000 E		call writestring
 00000619  BA 00000045 R		mov edx, offset PWprom1 ; print "has won!"
 0000061E  E8 00000000 E		call writestring
 00000623  E8 00000000 E		call crlf

 00000628  C9		   *	    leave  
 00000629  C2 0004			ret 4
 0000062C			PrintWinner endp


				COMMENT @
				print stats
				recieves:
				just a ton of statistics
				returns:
				nothing
				requires:
				edx registers
				@
 0000062C			PrintStats proc,
					lpvcgp:byte,
					lpvpgp:byte, 
					lcvcgp:byte, 
					lp1win:byte, 
					lp2win:byte, 
					lc1win:byte, 
					lc2win:byte, 
					ldraws:byte 
 0000062C  55		   *	    push   ebp
 0000062D  8B EC	   *	    mov    ebp, esp
 0000004F			.data
 0000004F 48 65 72 65 20		Pstats0 byte "Here are some stats:", 0
	   61 72 65 20 73
	   6F 6D 65 20 73
	   74 61 74 73 3A
	   00
 00000064 50 6C 61 79 65		Pstats1 byte "Player vs Computer games played: ", 0
	   72 20 76 73 20
	   43 6F 6D 70 75
	   74 65 72 20 67
	   61 6D 65 73 20
	   70 6C 61 79 65
	   64 3A 20 00
 00000086 50 6C 61 79 65		Pstats2 byte "Player vs Player games played: ", 0
	   72 20 76 73 20
	   50 6C 61 79 65
	   72 20 67 61 6D
	   65 73 20 70 6C
	   61 79 65 64 3A
	   20 00
 000000A6 43 6F 6D 70 75		Pstats3 byte "Computer vs Computer games played: ", 0
	   74 65 72 20 76
	   73 20 43 6F 6D
	   70 75 74 65 72
	   20 67 61 6D 65
	   73 20 70 6C 61
	   79 65 64 3A 20
	   00
 000000CA 50 6C 61 79 65		Pstats4 byte "Player 1 wins: ", 0
	   72 20 31 20 77
	   69 6E 73 3A 20
	   00
 000000DA 50 6C 61 79 65		Pstats5 byte "Player 2 wins: ", 0
	   72 20 32 20 77
	   69 6E 73 3A 20
	   00
 000000EA 43 6F 6D 70 75		Pstats6 byte "Computer 1 wins: ", 0
	   74 65 72 20 31
	   20 77 69 6E 73
	   3A 20 00
 000000FC 43 6F 6D 70 75		Pstats7 byte "Computer 2 wins: ", 0
	   74 65 72 20 32
	   20 77 69 6E 73
	   3A 20 00
 0000010E 44 72 61 77 73		Pstats8 byte "Draws: ", 0
	   3A 20 00

 0000062F			.code
 0000062F  B8 00000000			mov eax, 0 ; clear eax
					
 00000634  BA 0000004F R		mov edx, offset Pstats0
 00000639  E8 00000000 E		call writestring
 0000063E  E8 00000000 E		call crlf
					
 00000643  BA 00000064 R		mov edx, offset Pstats1
 00000648  E8 00000000 E		call writestring
 0000064D  8A 45 08			mov al, lpvcgp
 00000650  E8 00000000 E		call writedec
 00000655  E8 00000000 E		call crlf

 0000065A  BA 00000086 R		mov edx, offset Pstats2
 0000065F  E8 00000000 E		call writestring
 00000664  8A 45 0C			mov al, lpvpgp
 00000667  E8 00000000 E		call writedec
 0000066C  E8 00000000 E		call crlf

 00000671  BA 000000A6 R		mov edx, offset Pstats3
 00000676  E8 00000000 E		call writestring
 0000067B  8A 45 10			mov al, lcvcgp
 0000067E  E8 00000000 E		call writedec
 00000683  E8 00000000 E		call crlf

 00000688  BA 000000CA R		mov edx, offset Pstats4
 0000068D  E8 00000000 E		call writestring
 00000692  8A 45 14			mov al, lp1win
 00000695  E8 00000000 E		call writedec
 0000069A  E8 00000000 E		call crlf

 0000069F  BA 000000DA R		mov edx, offset Pstats5
 000006A4  E8 00000000 E		call writestring
 000006A9  8A 45 18			mov al, lp2win
 000006AC  E8 00000000 E		call writedec
 000006B1  E8 00000000 E		call crlf

 000006B6  BA 000000EA R		mov edx, offset Pstats6
 000006BB  E8 00000000 E		call writestring
 000006C0  8A 45 1C			mov al, lc1win
 000006C3  E8 00000000 E		call writedec
 000006C8  E8 00000000 E		call crlf

 000006CD  BA 000000FC R		mov edx, offset Pstats7
 000006D2  E8 00000000 E		call writestring
 000006D7  8A 45 20			mov al, lc2win
 000006DA  E8 00000000 E		call writedec
 000006DF  E8 00000000 E		call crlf

 000006E4  BA 0000010E R		mov edx, offset Pstats8
 000006E9  E8 00000000 E		call writestring
 000006EE  8A 45 24			mov al, ldraws
 000006F1  E8 00000000 E		call writedec
 000006F6  E8 00000000 E		call crlf

 000006FB  C9		   *	    leave  
 000006FC  C2 0008			ret 8
 000006FF			PrintStats endp















				COMMENT @
				check if the game is over in a draw
				recieves:
				board offset
				the offset for game draw condition
				returns:
				the draw condition
				requires:
				eax, ebx, ecx, edx registers
				@
 000006FF			CheckForDraw proc,
					boardOff:dword,
					retOff:dword
 000006FF  55		   *	    push   ebp
 00000700  8B EC	   *	    mov    ebp, esp
 00000116			.data
					
 00000116 00000000			CFDrow dword 0
 0000011A 00000000			CFDcol dword 0

 00000702			.code
					
					; if every space is full but nobody has won, then it's a draw

 00000702  C7 05 00000116 R		mov CFDrow, 0
	   00000000
 0000070C  C7 05 0000011A R		mov CFDcol, 0
	   00000000

 00000716			CFDol1:
 00000716  C7 05 0000011A R		mov CFDcol, 0
	   00000000
 00000720  B9 00000003			mov ecx, 3
 00000725			CFDil1:	
 00000725  8B 5D 08				mov ebx, boardOff ; get a space
 00000728  A1 00000116 R			mov eax, CFDrow
 0000072D  03 05 00000116 R			add eax, CFDrow
 00000733  03 05 00000116 R			add eax, CFDrow
 00000739  03 D8				add ebx, eax

 0000073B  8B 15 0000011A R			mov edx, CFDcol

 00000741  8A 04 13				mov al, byte ptr [ebx + edx] ; get 0,1, or 2 from spot

 00000744  3C 00				cmp al,0 ; check this space for 0
						; if any spot is zero, then this is not a tie
 00000746  74 23				je NotNull

 00000748  FF 05 0000011A R			inc CFDcol

 0000074E  E2 D5				loop CFDil1 ; inner loop

 00000750  FF 05 00000116 R		inc CFDrow ; move to the next row

 00000756  83 3D 00000116 R		cmp CFDrow, 3d
	   03
 0000075D  74 02			je CFDel1

 0000075F  EB B5		jmp CFDol1 ; outer loop
					
 00000761			CFDel1: ; not a draw yet
					
 00000761  8B 5D 0C			mov ebx, retOff
 00000764  C6 03 01			mov byte ptr [ebx], 1d

 00000767  C9		   *	    leave  
 00000768  C2 0008			ret 8

 0000076B			NotNull: ; it's a draw!

 0000076B  8B 5D 0C			mov ebx, retOff
 0000076E  C6 03 00			mov byte ptr [ebx], 0d

 00000771  C9		   *	    leave  
 00000772  C2 0008			ret 8
 00000775			CheckForDraw endp



				COMMENT @
				check if the game is over
				recieves:
				board offset
				the offset for game over condition
				winVal is the value we're checking for - X or O
				returns:
				the game over condition
				requires:
				eax, ebx, ecx, edx, esi registers
				@
 00000775			CheckGameOver proc,
					boardOff:dword,
					goOff:dword, 
					winVal:byte
 00000775  55		   *	    push   ebp
 00000776  8B EC	   *	    mov    ebp, esp
 0000011E			.data

 0000011E 00000000			CGOcounter dword 0

 00000122 00000000			CGOrow dword 0
 00000126 00000000			CGOcol dword 0

 00000778			.code

					; clear values
 00000778  C7 05 0000011E R		mov CGOcounter, 0
	   00000000
 00000782  C7 05 00000122 R		mov CGOrow, 0
	   00000000
 0000078C  C7 05 00000126 R		mov CGOcol, 0
	   00000000
					
					; check rows

 00000796			CGOloop0:
					
 00000796  B9 00000003			mov ecx, 3 ; loop 3 times - check every row
 0000079B  C7 05 00000126 R		mov CGOcol, 0
	   00000000
 000007A5  C7 05 0000011E R		mov CGOcounter, 0
	   00000000
 000007AF				CGOloop1:

 000007AF  8B 5D 08				mov ebx, boardOff ; move to correct row and col
 000007B2  03 1D 00000122 R			add ebx, CGOrow
 000007B8  03 1D 00000122 R			add ebx, CGOrow
 000007BE  03 1D 00000122 R			add ebx, CGOrow
 000007C4  8B 35 00000126 R			mov esi, CGOcol
 000007CA  8A 04 33				mov al, [ebx + esi] ; save current value in al

 000007CD  8A 5D 10				mov bl, winVal ; if this spot matches piece we're looking for (X or O)
 000007D0  3A 45 10				cmp al, winVal ; then increment counter by 1
 000007D3  75 06				jne notAWinner
 000007D5  FF 05 0000011E R			inc CGOcounter
 000007DB				notAWinner:
 000007DB  FF 05 00000126 R			inc CGOcol

 000007E1  E2 CC				loop CGOloop1

 000007E3  FF 05 00000122 R		inc CGOrow

 000007E9  83 3D 0000011E R		cmp CGOcounter, 3 ; check if this row is a winner
	   03
 000007F0  75 0C			jne CGOnext1

					; set win here
					; put result in goCondition
 000007F2  8B 5D 0C			mov ebx, goOff
 000007F5  8A 45 10			mov al, winVal
 000007F8  88 03			mov byte ptr [ebx], al
 000007FA  C9		   *	    leave  
 000007FB  C2 0009			ret 9

 000007FE			CGOnext1:

 000007FE  83 3D 00000122 R		cmp CGOrow, 3 ; if all rows checked, move on
	   03
 00000805  74 02			je CGOesc1

 00000807  E2 8D			loop CGOloop0

 00000809			CGOesc1:
					
					; check cols

 00000809  C7 05 0000011E R		mov CGOcounter, 0 ; now we'll check columns
	   00000000
 00000813  C7 05 00000122 R		mov CGOrow, 0
	   00000000
 0000081D  C7 05 00000126 R		mov CGOcol, 0
	   00000000

 00000827			CGOloop3:
					
 00000827  B9 00000003			mov ecx, 3
 0000082C  C7 05 00000122 R		mov CGOrow, 0
	   00000000
 00000836  C7 05 0000011E R		mov CGOcounter, 0
	   00000000
 00000840				CGOloop4:

 00000840  8B 5D 08				mov ebx, boardOff ; move to the right place
 00000843  03 1D 00000122 R			add ebx, CGOrow
 00000849  03 1D 00000122 R			add ebx, CGOrow
 0000084F  03 1D 00000122 R			add ebx, CGOrow
 00000855  8B 35 00000126 R			mov esi, CGOcol
 0000085B  8A 04 33				mov al, [ebx + esi]

 0000085E  3A 45 10				cmp al, winVal ; if this piece matches (X or O), increment
 00000861  75 06				jne notAWinner1
 00000863  FF 05 0000011E R			inc CGOcounter
 00000869				notAWinner1:
 00000869  FF 05 00000122 R			inc CGOrow ; increment row

 0000086F  E2 CF				loop CGOloop4

 00000871  FF 05 00000126 R		inc CGOcol

 00000877  83 3D 0000011E R		cmp CGOcounter, 3
	   03
 0000087E  75 0C			jne CGOnext2

					; set win here
					; put result in goCondition
 00000880  8B 5D 0C			mov ebx, goOff
 00000883  8A 45 10			mov al, winVal
 00000886  88 03			mov byte ptr [ebx], al
 00000888  C9		   *	    leave  
 00000889  C2 0009			ret 9

 0000088C			CGOnext2:

 0000088C  83 3D 00000126 R		cmp CGOcol, 3 ; if at column "3", excape loop
	   03
 00000893  74 02			je CGOesc2

 00000895  E2 90			loop CGOloop3 ; outer loop

 00000897			CGOesc2:

					; check diag1

 00000897  C7 05 0000011E R		mov CGOcounter, 0 ; clear vaue
	   00000000
 000008A1  C7 05 00000122 R		mov CGOrow, 0
	   00000000
 000008AB  C7 05 00000126 R		mov CGOcol, 0
	   00000000

 000008B5  B9 00000003			mov ecx, 3d

					; start on the top left and check diagonal

 000008BA			CGOdLoop1:
					
 000008BA  8B 5D 08				mov ebx, boardOff
 000008BD  03 1D 00000122 R			add ebx, CGOrow
 000008C3  03 1D 00000122 R			add ebx, CGOrow
 000008C9  03 1D 00000122 R			add ebx, CGOrow
 000008CF  8B 35 00000126 R			mov esi, CGOcol
 000008D5  8A 04 33				mov al, [ebx + esi] ; get the piece

 000008D8  3A 45 10				cmp al, winVal
 000008DB  75 06				jne notAWinner4
 000008DD  FF 05 0000011E R			inc CGOcounter ; inc counter if match

 000008E3				notAWinner4:
 000008E3  FF 05 00000126 R			inc CGOcol ; next row and column
 000008E9  FF 05 00000122 R			inc CGOrow
 000008EF  E2 C9			loop CGOdLoop1
						
 000008F1  83 3D 0000011E R		cmp CGOcounter, 3
	   03
 000008F8  75 0C			jne CGOnext4

					; set win here
					; put result in goCondition
 000008FA  8B 5D 0C			mov ebx, goOff
 000008FD  8A 45 10			mov al, winVal
 00000900  88 03			mov byte ptr [ebx], al
 00000902  C9		   *	    leave  
 00000903  C2 0009			ret 9

 00000906			CGOnext4:

					; check diag2

 00000906  C7 05 0000011E R		mov CGOcounter, 0
	   00000000
 00000910  C7 05 00000122 R		mov CGOrow, 0 ; start on top right
	   00000000
 0000091A  C7 05 00000126 R		mov CGOcol, 2
	   00000002

 00000924  B9 00000003			mov ecx, 3d

 00000929			CGOdLoop2:
					
 00000929  8B 5D 08				mov ebx, boardOff
 0000092C  03 1D 00000122 R			add ebx, CGOrow
 00000932  03 1D 00000122 R			add ebx, CGOrow
 00000938  03 1D 00000122 R			add ebx, CGOrow
 0000093E  8B 35 00000126 R			mov esi, CGOcol
 00000944  8A 04 33				mov al, [ebx + esi]

 00000947  3A 45 10				cmp al, winVal
 0000094A  75 06				jne notAWinner5
 0000094C  FF 05 0000011E R			inc CGOcounter

 00000952				notAWinner5:
 00000952  FF 0D 00000126 R			dec CGOcol ; move to the left column
 00000958  FF 05 00000122 R			inc CGOrow ; move to the below row
 0000095E  E2 C9			loop CGOdLoop2
						
 00000960  83 3D 0000011E R		cmp CGOcounter, 3
	   03
 00000967  75 0C			jne CGOnext6

					; set lack of win here
 00000969  8B 5D 0C			mov ebx, goOff
 0000096C  8A 45 10			mov al, winVal
 0000096F  88 03			mov byte ptr [ebx], al
 00000971  C9		   *	    leave  
 00000972  C2 0009			ret 9

 00000975			CGOnext6:
					
 00000975  8B 5D 0C			mov ebx, goOff
 00000978  C6 03 00			mov byte ptr [ebx], 0d

 0000097B  C9		   *	    leave  
 0000097C  C2 0009			ret 9
 0000097F			CheckGameOver endp


 0000097F			ComputerMove proc, 
					offStr:dword,
					pieceVal:byte,
					boardOff:dword
 0000097F  55		   *	    push   ebp
 00000980  8B EC	   *	    mov    ebp, esp
 0000012A			.data

 0000012A 20 77 69 6C 6C		CMp1 byte " will now take their turn.", 0
	   20 6E 6F 77 20
	   74 61 6B 65 20
	   74 68 65 69 72
	   20 74 75 72 6E
	   2E 00

 00000145 00000000			CMPguess1 dword 0
 00000149 00000000			CMPguess2 dword 0

 0000014D 00				CMPemptyCheck byte 0

 00000982			.code
 00000982  C6 05 0000014D R		mov CMPemptyCheck, 0d ; clear empty check
	   00

 00000989  8B 55 08			mov edx, offStr ; print whose turn it is
 0000098C  E8 00000000 E		call writestring
 00000991  BA 0000012A R		mov edx, offset CMp1
 00000996  E8 00000000 E		call writestring
 0000099B  E8 00000000 E		call crlf

 000009A0  C7 05 00000145 R		mov CMPguess1, 1d ; for checking middle
	   00000001
 000009AA  C7 05 00000149 R		mov CMPguess2, 1d
	   00000001

					; check middle
					INVOKE CheckIfEmpty, boardOff, offset CMPemptyCheck, CMPguess1, CMPguess2
 000009B4  FF 35 00000149 R *	    push   CMPguess2
 000009BA  FF 35 00000145 R *	    push   CMPguess1
 000009C0  68 0000014D R   *	    push   dword  ptr OFFSET FLAT: CMPemptyCheck
 000009C5  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 000009C8  E8 0000024A	   *	    call   CheckIfEmpty
 000009CD  80 3D 0000014D R		cmp CMPemptyCheck, 0
	   00
 000009D4  75 1C			jne CompPickLoop

					; put the piece into the middle if empty
					INVOKE PutPieceIn, boardOff, CMPguess1, CMPguess2, pieceVal
 000009D6  8A 45 0C	   *	    mov    al, byte  ptr ss:[ebp]+00Ch
 000009D9  50		   *	    push   eax
 000009DA  FF 35 00000149 R *	    push   CMPguess2
 000009E0  FF 35 00000145 R *	    push   CMPguess1
 000009E6  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 000009E9  E8 0000020B	   *	    call   PutPieceIn

 000009EE  C9		   *	    leave  
 000009EF  C2 0009			ret 9

 000009F2			CompPickLoop:

 000009F2  B8 00000000			mov eax, 0 ; pick a random row
 000009F7  B8 00000003			mov eax, 3
 000009FC  E8 00000000 E		call RandomRange
 00000A01  A3 00000145 R		mov CMPguess1, eax

 00000A06  B8 00000000			mov eax, 0 ; pick a random column
 00000A0B  B8 00000003			mov eax, 3
 00000A10  E8 00000000 E		call RandomRange
 00000A15  A3 00000149 R		mov CMPguess2, eax

					; check if this spot is available, if not, try again
					INVOKE CheckIfEmpty, boardOff, offset CMPemptyCheck, CMPguess1, CMPguess2
 00000A1A  FF 35 00000149 R *	    push   CMPguess2
 00000A20  FF 35 00000145 R *	    push   CMPguess1
 00000A26  68 0000014D R   *	    push   dword  ptr OFFSET FLAT: CMPemptyCheck
 00000A2B  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 00000A2E  E8 000001E4	   *	    call   CheckIfEmpty
 00000A33  80 3D 0000014D R		cmp CMPemptyCheck, 0
	   00
 00000A3A  75 B6			jne CompPickLoop

					; put the piece in if spot is open
					INVOKE PutPieceIn, boardOff, CMPguess1, CMPguess2, pieceVal
 00000A3C  8A 45 0C	   *	    mov    al, byte  ptr ss:[ebp]+00Ch
 00000A3F  50		   *	    push   eax
 00000A40  FF 35 00000149 R *	    push   CMPguess2
 00000A46  FF 35 00000145 R *	    push   CMPguess1
 00000A4C  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 00000A4F  E8 000001A5	   *	    call   PutPieceIn

 00000A54  C9		   *	    leave  
 00000A55  C2 0009			ret 9
 00000A58			ComputerMove endp


				COMMENT @
				Draws the ttt board
				recieves:
				board offset
				the current piece val (1 or 2 - X or O)
				returns:
				nothing
				requires:
				eax, ebx, ecx, edx registers
				@
 00000A58			DrawTTTBoard proc, 
					boardOff:dword, 
					pieceVal:byte
 00000A58  55		   *	    push   ebp
 00000A59  8B EC	   *	    mov    ebp, esp
 0000014E			.data
					
 0000014E 00000000			drow dword 0
 00000152 00000000			dcol dword 0

 = 00000040				blackTextOnRed = black + (red * 16)
 = 000000E0				blackTextOnYel = black + (yellow * 16)

 00000A5B			.code
 00000A5B  B8 00000000			mov eax, 0

 00000A60  C7 05 0000014E R		mov drow, 0 ; clear row
	   00000000
 00000A6A  C7 05 00000152 R		mov dcol, 0 ; clear col
	   00000000

 00000A74			ol2:

 00000A74  C7 05 00000152 R		mov dcol, 0
	   00000000
 00000A7E  B9 00000003			mov ecx, 3 ; inner loop 3 times
 00000A83			il2:	
 00000A83  B8 00000020			mov eax, 20h ; write a space
 00000A88  E8 00000000 E		call writechar

 00000A8D  8B 5D 08			mov ebx, boardOff ; move to the right row
 00000A90  A1 0000014E R		mov eax, drow
 00000A95  03 05 0000014E R		add eax, drow
 00000A9B  03 05 0000014E R		add eax, drow
 00000AA1  03 D8			add ebx, eax

 00000AA3  8B 15 00000152 R		mov edx, dcol ; move to the right col

 00000AA9  B8 00000000			mov eax, 0
 00000AAE  8A 04 13			mov al, byte ptr [ebx + edx] ; move the value into al

					; here, we'll draw based on data in 2d array
 00000AB1  3C 00			cmp al, 0
 00000AB3  75 09			jne Not0

 00000AB5  B0 2D			mov al, 2Dh
 00000AB7  E8 00000000 E		call writechar
 00000ABC  EB 32			jmp DoneWrite

 00000ABE			Not0: ; draw an X
 00000ABE  3C 01			cmp al, 1
 00000AC0  75 18			jne Not1
 00000AC2  B8 00000040			mov eax, blackTextOnRed
 00000AC7  E8 00000000 E		call SetTextColor
 00000ACC  B8 00000000			mov eax, 0
 00000AD1  B0 58			mov al, 58h
 00000AD3  E8 00000000 E		call writechar
 00000AD8  EB 16			jmp DoneWrite

 00000ADA			Not1: ; draw a O
 00000ADA  B8 000000E0			mov eax, blackTextOnYel
 00000ADF  E8 00000000 E		call SetTextColor
 00000AE4  B8 00000000			mov eax, 0
 00000AE9  B0 4F			mov al, 4Fh
 00000AEB  E8 00000000 E		call writechar

 00000AF0			DoneWrite:
					INVOKE ResetColor ; make the colors normal
 00000AF0  E8 0000003F	   *	    call   ResetColor

					INVOKE writeSpace
 00000AF5  E8 00000025	   *	    call   writeSpace

 00000AFA  FF 05 00000152 R		inc dcol ; move to the next col

 00000B00  E2 81			loop il2 

 00000B02  FF 05 0000014E R		inc drow ; outer loop

 00000B08  E8 00000000 E		call crlf

 00000B0D  83 3D 0000014E R		cmp drow, 3d
	   03
 00000B14  74 05			je el2

 00000B16  E9 FFFFFF59		jmp ol2

 00000B1B			el2:

 00000B1B  C9		   *	    leave  
 00000B1C  C2 0005			ret 5
 00000B1F			DrawTTTBoard endp
test3.asm(1123) : warning A6004:procedure argument or local not referenced : pieceVal



				COMMENT @
				makes some space in the loop above
				recieves:
				none
				returns:
				none
				requires:
				eax register
				@
 00000B1F			writeSpace proc
 00000156			.data
 00000B1F			.code
 00000B1F  B8 00000020			mov eax, 20h
 00000B24  E8 00000000 E		call writechar ; write space
 00000B29  B8 0000007C			mov eax, 7Ch
 00000B2E  E8 00000000 E		call writechar ; write line
 00000B33  C3				ret
 00000B34			writeSpace endp



				COMMENT @
				reset to normal colors
				recieves:
				none
				returns:
				none
				requires:
				none
				@
 00000B34			ResetColor proc
 00000156			.data
 = 0000000F				WhiteTextOnBla = white + (black * 16)
 00000B34			.code
 00000B34  B8 0000000F			mov eax, WhiteTextOnBla ; make the colors normal
 00000B39  E8 00000000 E		call SetTextColor
 00000B3E  C3				ret
 00000B3F			ResetColor endp








				COMMENT @
				flips active piece - X to O or vice versa
				recieves:
				offset for the active piece
				returns:
				value active piece
				requires:
				edx, ebx, eax registers
				@
 00000B3F			FlipActivePiece proc,
					apOff:dword
 00000B3F  55		   *	    push   ebp
 00000B40  8B EC	   *	    mov    ebp, esp
 00000156			.data
 00000B42			.code
 00000B42  8B 5D 08			mov ebx, apOff ; get the current active piece
 00000B45  8A 03			mov al, byte ptr [ebx]

 00000B47  3C 01			cmp al, 1
 00000B49  74 08			je FlipAdd

 00000B4B			FlipSub:
 00000B4B  FE C8			dec al ; flip 2 to 1
 00000B4D  88 03			mov byte ptr [ebx], al

 00000B4F  C9		   *	    leave  
 00000B50  C2 0004			ret 4

 00000B53			FlipAdd:
 00000B53  FE C0			inc al ; flip 1 to 2
 00000B55  88 03			mov byte ptr [ebx], al

 00000B57  C9		   *	    leave  
 00000B58  C2 0004			ret 4
 00000B5B			FlipActivePiece endp





				COMMENT @
				put a piece into the ttt board
				recieves:
				boardOffset
				row
				col
				whether this is an X or an O
				returns:
				value in whether this is an X or an O
				requires:
				edx, ebx, eax registers
				@
 00000B5B			PlayerMove proc, 
					offStr:dword,
					pieceVal:byte,
					boardOff:dword
 00000B5B  55		   *	    push   ebp
 00000B5C  8B EC	   *	    mov    ebp, esp
 00000156			.data
 00000156 20 77 69 6C 6C		p1 byte " will now take their turn.", 0
	   20 6E 6F 77 20
	   74 61 6B 65 20
	   74 68 65 69 72
	   20 74 75 72 6E
	   2E 00

 00000171 50 6C 65 61 73		p2 byte "Please input a row (0,1, or 2): ", 0
	   65 20 69 6E 70
	   75 74 20 61 20
	   72 6F 77 20 28
	   30 2C 31 2C 20
	   6F 72 20 32 29
	   3A 20 00
 00000192 50 6C 65 61 73		p3 byte "Please input a column (0,1, or 2): ", 0
	   65 20 69 6E 70
	   75 74 20 61 20
	   63 6F 6C 75 6D
	   6E 20 28 30 2C
	   31 2C 20 6F 72
	   20 32 29 3A 20
	   00

 000001B6 00000000			inputRow dword 0d
 000001BA 00000000			inputCol dword 0d

 000001BE 00				emptyCheck byte 0d

 00000B5E			.code
 00000B5E  8B 55 08			mov edx, offStr ; print whose turn it is 
 00000B61  E8 00000000 E		call writestring
 00000B66  BA 00000156 R		mov edx, offset p1 
 00000B6B  E8 00000000 E		call writestring
 00000B70  E8 00000000 E		call crlf

 00000B75			playerRetry:
 00000B75  BA 00000171 R		mov edx, offset p2 ; print the prompt
 00000B7A  E8 00000000 E		call writestring
 00000B7F  E8 00000000 E		call crlf

 00000B84  B8 00000000			mov eax, 0 
 00000B89  E8 00000000 E		call readdec ; get input

 00000B8E  83 F8 02			cmp eax, 2 ; make sure it's 0-2
 00000B91  77 E2			ja playerRetry

 00000B93  A3 000001B6 R		mov inputRow, eax

 00000B98  BA 00000192 R		mov edx, offset p3 ; print the prompt
 00000B9D  E8 00000000 E		call writestring
 00000BA2  E8 00000000 E		call crlf

 00000BA7  B8 00000000			mov eax, 0 
 00000BAC  E8 00000000 E		call readdec ; get input

 00000BB1  83 F8 02			cmp eax, 2 ; make sure it's 0-2
 00000BB4  77 BF			ja playerRetry

 00000BB6  A3 000001BA R		mov inputCol, eax

					; check if the space is empty, if not, retry
					INVOKE CheckIfEmpty, boardOff, offset emptyCheck, inputRow, inputCol
 00000BBB  FF 35 000001BA R *	    push   inputCol
 00000BC1  FF 35 000001B6 R *	    push   inputRow
 00000BC7  68 000001BE R   *	    push   dword  ptr OFFSET FLAT: emptyCheck
 00000BCC  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 00000BCF  E8 00000043	   *	    call   CheckIfEmpty
 00000BD4  80 3D 000001BE R		cmp emptyCheck, 0
	   00
 00000BDB  75 98			jne playerRetry

					; put the piece in 
					INVOKE PutPieceIn, boardOff, inputRow, inputCol, pieceVal
 00000BDD  8A 45 0C	   *	    mov    al, byte  ptr ss:[ebp]+00Ch
 00000BE0  50		   *	    push   eax
 00000BE1  FF 35 000001BA R *	    push   inputCol
 00000BE7  FF 35 000001B6 R *	    push   inputRow
 00000BED  FF 75 10	   *	    push   dword  ptr ss:[ebp]+000000010h
 00000BF0  E8 00000004	   *	    call   PutPieceIn

 00000BF5  C9		   *	    leave  
 00000BF6  C2 0009			ret 9
 00000BF9			PlayerMove endp




				COMMENT @
				put a piece into the ttt board
				recieves:
				boardOffset
				row
				col
				whether this is an X or an O
				returns:
				value in whether this is an X or an O
				requires:
				edx, ebx, eax registers
				@
 00000BF9			PutPieceIn proc,
					boardOff:dword, 
					rowIn:dword,
					colIn:dword, 
					pieceVal:byte
 00000BF9  55		   *	    push   ebp
 00000BFA  8B EC	   *	    mov    ebp, esp
 000001BF			.data
 00000BFC			.code
					
 00000BFC  8B 5D 08			mov ebx, boardOff ; get over to the given row
 00000BFF  8B 45 0C			mov eax, rowIn
 00000C02  03 45 0C			add eax, rowIn
 00000C05  03 45 0C			add eax, rowIn
 00000C08  03 D8			add ebx, eax

 00000C0A  8B 55 10			mov edx, colIn ; get over to the given col

 00000C0D  8A 45 14			mov al, pieceVal ; save piece into al
 00000C10  88 04 13			mov byte ptr [ebx + edx], al ; move the piece into the board

 00000C13  C9		   *	    leave  
 00000C14  C2 000D			ret 13
 00000C17			PutPieceIn endp




				COMMENT @
				check if a specific spot on the ttt board is empty
				recieves:
				boardOffset
				offset for storage for true or false - if empty for not
				row
				col
				returns:
				a value in storage offset
				requires:
				edx, ebx, eax registers
				@
 00000C17			CheckIfEmpty proc,
					boardOff:dword, 
					empOff:dword,
					rowIn:dword,
					colIn:dword
 00000C17  55		   *	    push   ebp
 00000C18  8B EC	   *	    mov    ebp, esp
 000001BF			.data
 00000C1A			.code

 00000C1A  8B 5D 08			mov ebx, boardOff
 00000C1D  8B 45 10			mov eax, rowIn ; move to the right row
 00000C20  03 45 10			add eax, rowIn
 00000C23  03 45 10			add eax, rowIn
 00000C26  03 D8			add ebx, eax

 00000C28  8B 55 14			mov edx, colIn ; move to the right column

 00000C2B  8B 4D 0C			mov ecx, empOff

 00000C2E  8A 04 13			mov al, byte ptr [ebx + edx] ; move the value in TTT array into some storage value
 00000C31  88 01			mov byte ptr [ecx], al ; save number from TTT array in storage

 00000C33  C9		   *	    leave  
 00000C34  C2 0010			ret 16
 00000C37			CheckIfEmpty endp






				COMMENT @
				decides who goes first p1c1 or p2c2
				recieves:
				offset for the first move value
				returns:
				value in the first move value
				requires:
				all registers
				@
 00000C37			FirstMoveRand proc,
					fmOff:dword
 00000C37  55		   *	    push   ebp
 00000C38  8B EC	   *	    mov    ebp, esp
 000001BF			.data
 00000C3A			.code
 00000C3A  B8 00000000			mov eax, 0

 00000C3F  B0 00			mov al, 0
 00000C41  B0 02			mov al, 2
 00000C43  E8 00000000 E		call RandomRange ; get a value 1 or 2

 00000C48  8B 5D 08			mov ebx, fmOff ; 
 00000C4B  88 03			mov byte ptr [ebx], al ; save input

 00000C4D  C9		   *	    leave  
 00000C4E  C2 0004			ret 4
 00000C51			FirstMoveRand endp

 00000C51			AnnounceFirstMove proc
 000001BF			.data
 000001BF 54 68 65 20 66		AFMp1 byte "The first move was decided randomly", 0 ; this is just a msg letting users know
	   69 72 73 74 20
	   6D 6F 76 65 20
	   77 61 73 20 64
	   65 63 69 64 65
	   64 20 72 61 6E
	   64 6F 6D 6C 79
	   00
 000001E3 54 68 65 20 66		AFMp2 byte "The first move will be: ", 0            ; the first move is random
	   69 72 73 74 20
	   6D 6F 76 65 20
	   77 69 6C 6C 20
	   62 65 3A 20 00
 00000C51			.code
 00000C51  BA 000001BF R		mov edx, offset AFMp1
 00000C56  E8 00000000 E		call writestring
 00000C5B  E8 00000000 E		call crlf

 00000C60  BA 000001E3 R		mov edx, offset AFMp2
 00000C65  E8 00000000 E		call writestring
 00000C6A  E8 00000000 E		call crlf

 00000C6F  C3				ret
 00000C70			AnnounceFirstMove endp






				COMMENT @
				set TTT board to all zeros
				recieves:
				board offset
				returns:
				nothing
				requires:
				all registers
				@
				; clear board
 00000C70			ClearBoard proc,
					boardOff:dword
 00000C70  55		   *	    push   ebp
 00000C71  8B EC	   *	    mov    ebp, esp
 000001FC			.data
 000001FC 00000000			row dword 0 ; start at row 0
 00000200 00000000			col dword 0

 00000C73			.code
					
 00000C73  C7 05 000001FC R		mov row, 0
	   00000000
 00000C7D  C7 05 00000200 R		mov col, 0
	   00000000

 00000C87			ol1:
 00000C87  C7 05 00000200 R		mov col, 0 ; start at col 0 each outer loop
	   00000000
 00000C91  B9 00000003			mov ecx, 3
 00000C96			il1:	
 00000C96  8B 5D 08			mov ebx, boardOff ; get the offset for the current cell in 2D array
 00000C99  A1 000001FC R		mov eax, row
 00000C9E  03 05 000001FC R		add eax, row
 00000CA4  03 05 000001FC R		add eax, row
 00000CAA  03 D8			add ebx, eax

 00000CAC  8B 15 00000200 R		mov edx, col

 00000CB2  C6 04 13 00			mov byte ptr [ebx + edx], 0h ; move zero into this cell

 00000CB6  FF 05 00000200 R		inc col ; move to the next column

 00000CBC  E2 D8			loop il1

 00000CBE  FF 05 000001FC R		inc row

 00000CC4  83 3D 000001FC R		cmp row, 3d ; if we're at row "3", exit
	   03
 00000CCB  74 02			je el1

 00000CCD  EB B8		jmp ol1
					
 00000CCF			el1:
					

 00000CCF  C9		   *	    leave  
 00000CD0  C2 0004			ret 4
 00000CD3			ClearBoard endp

				COMMENT @
				Clears registers
				Recieves:
				nothing
				Returns:
				nothing
				requires:
				nothing
				@
 00000CD3			ClearRegs proc
 00000204			.data
 00000CD3			.code
 00000CD3  B8 00000000			mov eax, 0d
 00000CD8  BB 00000000			mov ebx, 0d
 00000CDD  B9 00000000			mov ecx, 0d
 00000CE2  BA 00000000			mov edx, 0d
 00000CE7  BE 00000000			mov esi, 0d
 00000CEC  C3				ret
 00000CED			ClearRegs endp


				COMMENT @
				Displays menu
				recieves:
				offset for menu option holder in main
				returns:
				user input using given offset
				requires:
				edx, ebx, eax registers
				@
				; display menu
 00000CED			DisplayMenu proc,
					menOff:dword ; this value stores the return value
 00000CED  55		   *	    push   ebp
 00000CEE  8B EC	   *	    mov    ebp, esp
 00000204			.data
 00000204 48 69 20 68 65		menu1 byte "Hi here are some options: ", 0Ah, 0Dh, 
	   72 65 20 61 72
	   65 20 73 6F 6D
	   65 20 6F 70 74
	   69 6F 6E 73 3A
	   20 0A 0D 31 3A
	   20 50 76 43 2E
	   0A 0D 32 3A 20
	   50 76 50 0A 0D
	   33 3A 20 43 76
	   43 0A 0D 34 3A
	   20 53 74 61 74
	   73 0A 0D 35 3A
	   20 45 78 69 74
	   0A 0D 50 6C 7A
	   20 65 6E 74 65
	   72 20 31 20 74
	   6F 20 35 3A 20
	   00
								"1: PvC.", 0Ah, 0Dh, 
								"2: PvP", 0Ah, 0Dh, 
								"3: CvC", 0Ah, 0Dh, 
								"4: Stats", 0Ah, 0Dh, 
								"5: Exit", 0Ah, 0Dh, 
								"Plz enter 1 to 5: ", 0
					
 00000CF0			.code
 00000CF0  BA 00000204 R		mov edx, offset menu1 ; show menu ; show prompt
 00000CF5  E8 00000000 E		call writestring
 00000CFA  E8 00000000 E		call crlf

 00000CFF  E8 00000000 E		call readdec ; get input

 00000D04  8B 5D 08			mov ebx, menOff ; save input
 00000D07  88 03			mov byte ptr [ebx], al


 00000D09  C9		   *	    leave  
 00000D0A  C2 0004			ret 4
 00000D0D			DisplayMenu endp

				COMMENT @
				Displays second menu
				recieves:
				offset for menu option holder in main
				returns:
				user input using given offset
				requires:
				edx, ebx, eax registers
				@
				; display menu
 00000D0D			DisplayGvG proc,
					gvgOff:dword
 00000D0D  55		   *	    push   ebp
 00000D0E  8B EC	   *	    mov    ebp, esp
 0000025F			.data
 0000025F 50 6C 61 79 20		menu2 byte "Play Griffons vs Gargoyles mode?", 0Ah, 0Dh, 
	   47 72 69 66 66
	   6F 6E 73 20 76
	   73 20 47 61 72
	   67 6F 79 6C 65
	   73 20 6D 6F 64
	   65 3F 0A 0D 49
	   6E 20 74 68 69
	   73 20 6D 6F 64
	   65 2C 20 65 76
	   65 72 79 20 58
	   20 69 73 20 61
	   20 47 72 69 66
	   66 6F 6E 20 61
	   6E 64 20 65 76
	   65 72 79 20 4F
	   20 69 73 20 61
	   20 47 61 72 67
	   6F 79 6C 65 2E
	   0A 0D 41 66 74
	   65 72 20 65 76
	   65 72 79 20 72
	   6F 75 6E 64 2C
	   20 74 68 65 79
	   20 61 6C 6C 20
	   66 69 67 68 74
	   20 65 61 63 68
	   20 6F 74 68 65
	   72 20 61 6E 64
	   20 7E 68 61 6C
	   66 20 6F 66 20
	   74 68 65 6D 20
	   67 65 74 20 6B
	   6E 6F 63 6B 65
	   64 20 6F 66 66
	   20 74 68 65 20
	   62 6F 61 72 64
	   2E 0A 0D 47 72
	   69 66 66 6F 6E
	   73 20 66 69 67
	   68 74 20 6E 65
	   61 72 62 79 20
	   67 61 72 67 73
	   20 61 6E 64 20
	   76 69 63 65 20
	   76 65 72 73 61
	   2E 20 49 66 20
	   74 68 65 79 20
	   77 69 6E 2C 20
	   74 68 61 74 20
	   67 72 69 66 66
	   6F 6E 20 6F 72
	   20 67 61 72 67
	   20 67 65 74 73
	   20 73 74 72 6F
	   6E 67 65 72 2E
	   0A 0D 31 3A 20
	   59 65 73 2E 0A
	   0D 32 3A 20 4E
	   6F 0A 0D 50 6C
	   7A 20 65 6E 74
	   65 72 20 31 20
	   74 6F 20 32 3A
	   20 00
								"In this mode, every X is a Griffon and every O is a Gargoyle.", 0Ah, 0Dh, 
								"After every round, they all fight each other and ~half of them get knocked off the board.", 0Ah, 0Dh, 
								"Griffons fight nearby gargs and vice versa. If they win, that griffon or garg gets stronger.", 0Ah, 0Dh, 
								"1: Yes.", 0Ah, 0Dh, 
								"2: No", 0Ah, 0Dh, 
								"Plz enter 1 to 2: ", 0
					
 00000D10			.code
 00000D10  BA 0000025F R		mov edx, offset menu2 ; show menu
 00000D15  E8 00000000 E		call writestring
 00000D1A  E8 00000000 E		call crlf

 00000D1F  E8 00000000 E		call readdec ; get input

 00000D24  8B 5D 08			mov ebx, gvgOff ; save input
 00000D27  88 03			mov byte ptr [ebx], al


 00000D29  C9		   *	    leave  
 00000D2A  C2 0004			ret 4
 00000D2D			DisplayGvG endp


				end main
Microsoft (R) Macro Assembler Version 14.23.28106.4	    12/10/19 00:59:07
	test3.as					     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_BSS . . . . . . . . . . . . . .	32 Bit	 00000000 Para	  Public  'BSS'  
_DATA  . . . . . . . . . . . . .	32 Bit	 0000039C Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000D2D Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

AnnounceFirstMove  . . . . . . .	P Near	 00000C51 _TEXT	Length= 0000001F Public STDCALL
CheckForDraw . . . . . . . . . .	P Near	 000006FF _TEXT	Length= 00000076 Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  retOff . . . . . . . . . . . .	DWord	 bp + 0000000C
  CFDol1 . . . . . . . . . . . .	L Near	 00000716 _TEXT	
  CFDil1 . . . . . . . . . . . .	L Near	 00000725 _TEXT	
  CFDel1 . . . . . . . . . . . .	L Near	 00000761 _TEXT	
  NotNull  . . . . . . . . . . .	L Near	 0000076B _TEXT	
CheckGameOver  . . . . . . . . .	P Near	 00000775 _TEXT	Length= 0000020A Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  goOff  . . . . . . . . . . . .	DWord	 bp + 0000000C
  winVal . . . . . . . . . . . .	Byte	 bp + 00000010
  CGOloop0 . . . . . . . . . . .	L Near	 00000796 _TEXT	
  CGOloop1 . . . . . . . . . . .	L Near	 000007AF _TEXT	
  notAWinner . . . . . . . . . .	L Near	 000007DB _TEXT	
  CGOnext1 . . . . . . . . . . .	L Near	 000007FE _TEXT	
  CGOesc1  . . . . . . . . . . .	L Near	 00000809 _TEXT	
  CGOloop3 . . . . . . . . . . .	L Near	 00000827 _TEXT	
  CGOloop4 . . . . . . . . . . .	L Near	 00000840 _TEXT	
  notAWinner1  . . . . . . . . .	L Near	 00000869 _TEXT	
  CGOnext2 . . . . . . . . . . .	L Near	 0000088C _TEXT	
  CGOesc2  . . . . . . . . . . .	L Near	 00000897 _TEXT	
  CGOdLoop1  . . . . . . . . . .	L Near	 000008BA _TEXT	
  notAWinner4  . . . . . . . . .	L Near	 000008E3 _TEXT	
  CGOnext4 . . . . . . . . . . .	L Near	 00000906 _TEXT	
  CGOdLoop2  . . . . . . . . . .	L Near	 00000929 _TEXT	
  notAWinner5  . . . . . . . . .	L Near	 00000952 _TEXT	
  CGOnext6 . . . . . . . . . . .	L Near	 00000975 _TEXT	
CheckIfEmpty . . . . . . . . . .	P Near	 00000C17 _TEXT	Length= 00000020 Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  empOff . . . . . . . . . . . .	DWord	 bp + 0000000C
  rowIn  . . . . . . . . . . . .	DWord	 bp + 00000010
  colIn  . . . . . . . . . . . .	DWord	 bp + 00000014
ClearBoard . . . . . . . . . . .	P Near	 00000C70 _TEXT	Length= 00000063 Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  ol1  . . . . . . . . . . . . .	L Near	 00000C87 _TEXT	
  il1  . . . . . . . . . . . . .	L Near	 00000C96 _TEXT	
  el1  . . . . . . . . . . . . .	L Near	 00000CCF _TEXT	
ClearRegs  . . . . . . . . . . .	P Near	 00000CD3 _TEXT	Length= 0000001A Public STDCALL
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ComputerMove . . . . . . . . . .	P Near	 0000097F _TEXT	Length= 000000D9 Public STDCALL
  offStr . . . . . . . . . . . .	DWord	 bp + 00000008
  pieceVal . . . . . . . . . . .	Byte	 bp + 0000000C
  boardOff . . . . . . . . . . .	DWord	 bp + 00000010
  CompPickLoop . . . . . . . . .	L Near	 000009F2 _TEXT	
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisplayGvG . . . . . . . . . . .	P Near	 00000D0D _TEXT	Length= 00000020 Public STDCALL
  gvgOff . . . . . . . . . . . .	DWord	 bp + 00000008
DisplayMenu  . . . . . . . . . .	P Near	 00000CED _TEXT	Length= 00000020 Public STDCALL
  menOff . . . . . . . . . . . .	DWord	 bp + 00000008
DrawTTTBoard . . . . . . . . . .	P Near	 00000A58 _TEXT	Length= 000000C7 Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  pieceVal . . . . . . . . . . .	Byte	 bp + 0000000C
  ol2  . . . . . . . . . . . . .	L Near	 00000A74 _TEXT	
  il2  . . . . . . . . . . . . .	L Near	 00000A83 _TEXT	
  Not0 . . . . . . . . . . . . .	L Near	 00000ABE _TEXT	
  Not1 . . . . . . . . . . . . .	L Near	 00000ADA _TEXT	
  DoneWrite  . . . . . . . . . .	L Near	 00000AF0 _TEXT	
  el2  . . . . . . . . . . . . .	L Near	 00000B1B _TEXT	
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FirstMoveRand  . . . . . . . . .	P Near	 00000C37 _TEXT	Length= 0000001A Public STDCALL
  fmOff  . . . . . . . . . . . .	DWord	 bp + 00000008
FlipActivePiece  . . . . . . . .	P Near	 00000B3F _TEXT	Length= 0000001C Public STDCALL
  apOff  . . . . . . . . . . . .	DWord	 bp + 00000008
  FlipSub  . . . . . . . . . . .	L Near	 00000B4B _TEXT	
  FlipAdd  . . . . . . . . . . .	L Near	 00000B53 _TEXT	
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PlayerMove . . . . . . . . . . .	P Near	 00000B5B _TEXT	Length= 0000009E Public STDCALL
  offStr . . . . . . . . . . . .	DWord	 bp + 00000008
  pieceVal . . . . . . . . . . .	Byte	 bp + 0000000C
  boardOff . . . . . . . . . . .	DWord	 bp + 00000010
  playerRetry  . . . . . . . . .	L Near	 00000B75 _TEXT	
PrintStats . . . . . . . . . . .	P Near	 0000062C _TEXT	Length= 000000D3 Public STDCALL
  lpvcgp . . . . . . . . . . . .	Byte	 bp + 00000008
  lpvpgp . . . . . . . . . . . .	Byte	 bp + 0000000C
  lcvcgp . . . . . . . . . . . .	Byte	 bp + 00000010
  lp1win . . . . . . . . . . . .	Byte	 bp + 00000014
  lp2win . . . . . . . . . . . .	Byte	 bp + 00000018
  lc1win . . . . . . . . . . . .	Byte	 bp + 0000001C
  lc2win . . . . . . . . . . . .	Byte	 bp + 00000020
  ldraws . . . . . . . . . . . .	Byte	 bp + 00000024
PrintWinner  . . . . . . . . . .	P Near	 0000060E _TEXT	Length= 0000001E Public STDCALL
  winOff . . . . . . . . . . . .	DWord	 bp + 00000008
PutPieceIn . . . . . . . . . . .	P Near	 00000BF9 _TEXT	Length= 0000001E Public STDCALL
  boardOff . . . . . . . . . . .	DWord	 bp + 00000008
  rowIn  . . . . . . . . . . . .	DWord	 bp + 0000000C
  colIn  . . . . . . . . . . . .	DWord	 bp + 00000010
  pieceVal . . . . . . . . . . .	Byte	 bp + 00000014
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResetColor . . . . . . . . . . .	P Near	 00000B34 _TEXT	Length= 0000000B Public STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000060E Public STDCALL
  MenuL  . . . . . . . . . . . .	L Near	 00000000 _TEXT	
  PvCl . . . . . . . . . . . . .	L Near	 00000044 _TEXT	
  firstMove1 . . . . . . . . . .	L Near	 00000078 _TEXT	
  firstMove2 . . . . . . . . . .	L Near	 00000106 _TEXT	
  winDet0  . . . . . . . . . . .	L Near	 00000192 _TEXT	
  WinTree1 . . . . . . . . . . .	L Near	 000001A7 _TEXT	
  WinTree0 . . . . . . . . . . .	L Near	 000001C7 _TEXT	
  DrawDet0 . . . . . . . . . . .	L Near	 000001E7 _TEXT	
  PvCle  . . . . . . . . . . . .	L Near	 00000201 _TEXT	
  PvPl . . . . . . . . . . . . .	L Near	 00000206 _TEXT	
  firstMove3 . . . . . . . . . .	L Near	 0000023A _TEXT	
  firstMove4 . . . . . . . . . .	L Near	 000002C8 _TEXT	
  winDet1  . . . . . . . . . . .	L Near	 0000034F _TEXT	
  WinTree4 . . . . . . . . . . .	L Near	 00000364 _TEXT	
  WinTree3 . . . . . . . . . . .	L Near	 00000384 _TEXT	
  DrawDet1 . . . . . . . . . . .	L Near	 000003A4 _TEXT	
  PvPle  . . . . . . . . . . . .	L Near	 000003BE _TEXT	
  CvCl . . . . . . . . . . . . .	L Near	 000003C3 _TEXT	
  firstMove5 . . . . . . . . . .	L Near	 000003F7 _TEXT	
  firstMove6 . . . . . . . . . .	L Near	 0000048A _TEXT	
  winDet3  . . . . . . . . . . .	L Near	 00000516 _TEXT	
  WinTree8 . . . . . . . . . . .	L Near	 0000052B _TEXT	
  WinTree7 . . . . . . . . . . .	L Near	 0000054B _TEXT	
  DrawDet3 . . . . . . . . . . .	L Near	 0000056B _TEXT	
  CvCle  . . . . . . . . . . . .	L Near	 00000585 _TEXT	
  statsl . . . . . . . . . . . .	L Near	 0000058A _TEXT	
  exitl  . . . . . . . . . . . .	L Near	 000005D2 _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
writeSpace . . . . . . . . . . .	P Near	 00000B1F _TEXT	Length= 00000015 Public STDCALL
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
AFMp1  . . . . . . . . . . . . .	Byte	 000001BF _DATA	
AFMp2  . . . . . . . . . . . . .	Byte	 000001E3 _DATA	
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CFDcol . . . . . . . . . . . . .	DWord	 0000011A _DATA	
CFDrow . . . . . . . . . . . . .	DWord	 00000116 _DATA	
CGOcol . . . . . . . . . . . . .	DWord	 00000126 _DATA	
CGOcounter . . . . . . . . . . .	DWord	 0000011E _DATA	
CGOrow . . . . . . . . . . . . .	DWord	 00000122 _DATA	
CMPemptyCheck  . . . . . . . . .	Byte	 0000014D _DATA	
CMPguess1  . . . . . . . . . . .	DWord	 00000145 _DATA	
CMPguess2  . . . . . . . . . . .	DWord	 00000149 _DATA	
CMp1 . . . . . . . . . . . . . .	Byte	 0000012A _DATA	
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PWprom1  . . . . . . . . . . . .	Byte	 00000045 _DATA	
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
Pstats0  . . . . . . . . . . . .	Byte	 0000004F _DATA	
Pstats1  . . . . . . . . . . . .	Byte	 00000064 _DATA	
Pstats2  . . . . . . . . . . . .	Byte	 00000086 _DATA	
Pstats3  . . . . . . . . . . . .	Byte	 000000A6 _DATA	
Pstats4  . . . . . . . . . . . .	Byte	 000000CA _DATA	
Pstats5  . . . . . . . . . . . .	Byte	 000000DA _DATA	
Pstats6  . . . . . . . . . . . .	Byte	 000000EA _DATA	
Pstats7  . . . . . . . . . . . .	Byte	 000000FC _DATA	
Pstats8  . . . . . . . . . . . .	Byte	 0000010E _DATA	
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
TTTArray . . . . . . . . . . . .	Byte	 00000001 _DATA	
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WhiteTextOnBla . . . . . . . . .	Number	 0000000Fh   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
blackTextOnRed . . . . . . . . .	Number	 00000040h   
blackTextOnYel . . . . . . . . .	Number	 000000E0h   
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
c1win  . . . . . . . . . . . . .	Byte	 00000042 _DATA	
c2win  . . . . . . . . . . . . .	Byte	 00000043 _DATA	
col  . . . . . . . . . . . . . .	DWord	 00000200 _DATA	
cstring1 . . . . . . . . . . . .	Byte	 00000024 _DATA	
cstring2 . . . . . . . . . . . .	Byte	 0000002F _DATA	
currentPiece . . . . . . . . . .	Byte	 0000003A _DATA	
cvcgp  . . . . . . . . . . . . .	Byte	 0000003F _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
dcol . . . . . . . . . . . . . .	DWord	 00000152 _DATA	
drawCondition  . . . . . . . . .	Byte	 0000003C _DATA	
draws  . . . . . . . . . . . . .	Byte	 00000044 _DATA	
drow . . . . . . . . . . . . . .	DWord	 0000014E _DATA	
emptyCheck . . . . . . . . . . .	Byte	 000001BE _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
firstMoveDec . . . . . . . . . .	Byte	 0000000A _DATA	
goCondition  . . . . . . . . . .	Byte	 0000003B _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
inputCol . . . . . . . . . . . .	DWord	 000001BA _DATA	
inputRow . . . . . . . . . . . .	DWord	 000001B6 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
menu1  . . . . . . . . . . . . .	Byte	 00000204 _DATA	
menu2  . . . . . . . . . . . . .	Byte	 0000025F _DATA	
menuOption . . . . . . . . . . .	Byte	 00000000 _DATA	
nobodys1 . . . . . . . . . . . .	Byte	 0000000B _DATA	
p1win  . . . . . . . . . . . . .	Byte	 00000040 _DATA	
p1 . . . . . . . . . . . . . . .	Byte	 00000156 _DATA	
p2win  . . . . . . . . . . . . .	Byte	 00000041 _DATA	
p2 . . . . . . . . . . . . . . .	Byte	 00000171 _DATA	
p3 . . . . . . . . . . . . . . .	Byte	 00000192 _DATA	
pstring1 . . . . . . . . . . . .	Byte	 00000012 _DATA	
pstring2 . . . . . . . . . . . .	Byte	 0000001B _DATA	
pvcgp  . . . . . . . . . . . . .	Byte	 0000003D _DATA	
pvpgp  . . . . . . . . . . . . .	Byte	 0000003E _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
rowSize  . . . . . . . . . . . .	Number	 00000003h   
row  . . . . . . . . . . . . . .	DWord	 000001FC _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   1 Warnings
	   0 Errors
